shader_type spatial;

uniform vec3 albedo : source_color; //Color of water
uniform vec3 albedo2 : source_color; // color of frenel reflection
uniform float  metallic : hint_range(0.0, 1.0, 0.1) = 0; // metalic value
uniform float  roughness : hint_range(0.0, 1.0, 0.1) = 0.02; // rughness value
uniform sampler2D textureNormal1; //normal map for water 2d
uniform sampler2D textureNormal2; // another normal map for water 2d as offset combonation with first
uniform sampler2D wave; // noise to generate 3d vertex waves
uniform vec2 waveDirection1 = vec2(2.0,0.0); // vector to give movement direction to 2d noise
uniform vec2 waveDirection2 = vec2(0.0,1.0); // another vector to give movemnt to 2d noise
uniform float timeScale : hint_range(0.0, 0.2, 0.005) = 0.025; // a float used to scale down TIME to a usable value driver
uniform float hightScale = 0.15; // float to determin the hight of waves
uniform float noiseScale = 10.0; // float to change the noise for vertex displacement

// Depth Controller Variables
uniform vec4 colorDeep : source_color; // color of deep water
uniform vec4 colorShallow : source_color; // color of shalow water
uniform float beersLaw = 2.0; //value governing the fall off of light in the depths of water
uniform float depthOffset = -0.75; // as above
uniform sampler2D depthTextureRate : hint_depth_texture, filter_linear_mipmap;
uniform sampler2D screenTexture : hint_screen_texture, filter_linear_mipmap;

// Edge Fome controllers
uniform float edgeScale = 0.1;
uniform float near = 1.0;
uniform float far = 100.0;
uniform vec3 edgeColor : source_color;


//varying variables
varying float height;
varying vec3 worldPos;

float edge(float depth){
	depth = 2.0* depth-1.0;
	return near * far / (far + depth * (near -  far));
}

float frenel(float amount, vec3 normal, vec3 view) {
	return pow((1.0 - clamp(dot(normalize(normal), normalize(view)), 0.0, 1.0)), amount); 
}


void vertex() {
	// Called for every vertex the material is visible on.
	
	worldPos = (MODEL_MATRIX * vec4(VERTEX, 1.0)).xyz;
	height = texture(wave, worldPos.xz / noiseScale + TIME * timeScale).r;
	VERTEX.y += height * hightScale;
	
}

void fragment() {
	// Called for every pixel the material is visible on.
	
	//Depth calculators
	float depthTexture = texture(depthTextureRate, SCREEN_UV).r * 2.0 - 1.0;
	float depth = PROJECTION_MATRIX[3][2] / (depthTexture + PROJECTION_MATRIX[2][2]);
	float depthBlend = exp((depth+VERTEX.z + depthOffset)* -beersLaw);
	depthBlend = clamp(1.0 - depthBlend, 0.0, 1.0);
	float depthBlednPower = clamp(pow(depthBlend, 2.5), 0.0, 1.0);
	
	vec3 screenColor = textureLod(screenTexture, SCREEN_UV, depthBlednPower * 2.5).rgb;
	vec3 depthColor = mix(colorShallow.rgb , colorDeep.rgb, depthBlednPower);
	vec3 color = mix(screenColor * depthColor, depthColor * 0.25, depthBlednPower * 0.5);
	
	//edge calculators
	float zDepth = edge(texture(depthTextureRate, SCREEN_UV).x);
	float zPos = edge(FRAGCOORD.z);
	float zDif = zDepth - zPos;
	
	
	//setting up time conditions to create movement
	vec2 time = (TIME * waveDirection1) * timeScale;
	vec2 time2 = (TIME * waveDirection2) * timeScale;
	
	//blend the normal maps and move them over time
	vec3 normalBlend = mix(texture(textureNormal1, worldPos.xz + time).rgb, texture(textureNormal2, worldPos.xz + time2).rgb, 0.5);
	//calculate frenel
	float frenel = frenel(5.0, NORMAL, VIEW);
	vec3 surfaceColor = mix(albedo, albedo2, frenel);
	
	vec3 normal = texture(textureNormal1,UV).rgb;
	
	vec3 depthColorAdj =  mix(edgeColor, color, step(edgeScale, zDif));
	
	
	ALBEDO = clamp(surfaceColor + depthColorAdj, vec3(0.0), vec3(1.0));//mix(surfaceColor, color, 0.75);
	METALLIC = metallic;
	ROUGHNESS = roughness;
	NORMAL_MAP = normalBlend;
}